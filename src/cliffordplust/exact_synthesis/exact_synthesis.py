# Copyright 2024-2025 Olivier Romain, Francis Blais, Vincent Girouard, Marius Trudeau
#
#    Licensed under the Apache License, Version 2.0 (the "License");
#    you may not use this file except in compliance with the License.
#    You may obtain a copy of the License at
#
#        http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS,
#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#    See the License for the specific language governing permissions and
#    limitations under the License.

"""
This module performs the exact synthesis of any 2x2 unitary matrix with entries in D[\u03C9] into a
sequence of H and T gates, up to a global phase. It also contains multiple functions to characterize and
generate sequences of H and T gates. 

The algorithm is based on the paper ["Fast and efficient exact synthesis of single qubit unitaries
generated by Clifford and T gates](https://arxiv.org/abs/1206.5236) by Vadym Kliuchnikov, Dmitri Maslov,
and Michele Mosca.
"""

import os
import json

import numpy as np

from cliffordplust.rings import Domega

H_11 = Domega((-1, 1), (0, 0), (1, 1), (0, 0))  # 1st element of H gate (1/sqrt(2))
T_11 = Domega((0, 0), (0, 0), (0, 0), (1, 0))  # 1st element of T gate (1)
T_12 = Domega((0, 0), (0, 0), (0, 0), (0, 0))  # 2nd element of T gate (0)
T_22 = Domega((0, 0), (0, 0), (1, 0), (0, 0))  # 4th element of T gate (omega)
T_22_INV = Domega((-1, 0), (0, 0), (0, 0), (0, 0))  # 4th element of T^-1 gate (omega^7)
H = np.array([[H_11, H_11], [H_11, -H_11]], dtype=Domega)  # H gate
T = np.array([[T_11, T_12], [T_12, T_22]], dtype=Domega)  # T gate
T_INV = np.array([[T_11, T_12], [T_12, T_22_INV]], dtype=Domega)  # Inverse of T gate
I = np.array([[T_11, T_12], [T_12, T_11]], dtype=Domega)  # Identity
OMEGA = Domega((0, 0), (0, 0), (1, 0), (0, 0))  # OMEGA = e^(i*pi/4)
W = np.multiply(OMEGA, I)  # Gloabal phase gate


def exact_synthesis_alg(U: np.array) -> str:
    """Decompose an unitary 2x2 matrix with elements in \u2145[\u03C9] into a sequence of W, H and T
    gates.

    Args:
        U (np.array): Unitary 2x2 matrix to decompose, with elements in Domega

    Returns:
        str: Sequence of W, H and T gates to decompose the matrix

    Raises:
        TypeError: If matrix elements are not elements of the class Domega
        TypeError: If the matrix is not 2x2
        ValueError: If the matrix is not unitary
    """
    if not np.all([isinstance(element, Domega) for element in U.flatten()]):
        raise TypeError(f"Matrix elements must be of class Domega. Got {type(U[0][0])}.")

    elif U.shape != (2, 2):
        raise TypeError(f"Matrix must be of size 2x2. Got shape {U.shape}.")

    elif not is_unitary(U):
        raise ValueError("Matrix must be unitary. Got U=\n", U)

    u3_sequence, u3 = exact_synthesis_reduc(U)
    s3_sequence = lookup_sequence(u3)
    final_sequence = u3_sequence + s3_sequence
    return final_sequence


def exact_synthesis_reduc(U: np.array) -> tuple[str, np.array]:
    """Compute the exact synthesis reduction of an unitary 2x2 matrix with elements in \u2145[\u03C9] into the
    sequence that reduces the unitary and a matrix with a sde <= 3.

    The algorithm is based on the paper ["Fast and efficient exact synthesis of single qubit unitaries
    generated by Clifford and T gates](https://arxiv.org/abs/1206.5236) by Vadym Kliuchnikov, Dmitri Maslov,
    and Michele Mosca.

    Args:
        U (np.array): Unitary 2x2 array to synthesize with elements in Domega

    Returns:
        str: Sequence of H and T gates to synthesize the matrix
        np.array: Remaining matrix after reduction with a sde <3

    Raises:
        TypeError: If the matrix elements are not instances of the class Domega
        TypeError: If the matrix is not 2x2
        ValueError: If the matrix is not unitary
    """

    if not np.all([isinstance(element, Domega) for element in U.flatten()]):
        raise TypeError(f"Matrix elements must be of class Domega. Got {type(U[0][0])}.")

    elif U.shape != (2, 2):
        raise TypeError(f"Matrix must be of size 2x2. Got shape {U.shape}.")

    elif not is_unitary(U):
        raise ValueError("Matrix must be unitary. Got U=\n", U)

    sequence: str = ""
    norm_z = U[0, 0] * U[0, 0].complex_conjugate()
    s = norm_z.sde()

    # Reduce sde until sde <= 3
    while s > 3:

        # Look for the k that reduces the sde by 1
        for k in [0, 1, 2, 3]:
            U_prime = H @ np.linalg.matrix_power(T_INV, k) @ U
            norm_z_prime = U_prime[0, 0] * U_prime[0, 0].complex_conjugate()

            # Add found k to sequence and update U and s
            if norm_z_prime.sde() == s - 1:
                sequence += k * "T" + "H"
                s = norm_z_prime.sde()
                U = U_prime
                break
    return sequence, U


def lookup_sequence(U: np.array) -> str:
    """Find the sequence of W, H and T gates to synthesize a matrix with elements in \u2145[\u03C9] by
    looking in the S3 table.

    Args:
        U (np.array): Matrix to synthesize

    Returns:
        str: Sequence of W, H and T gates to synthesize the matrix

    Raises:
        TypeError: If the matrix elements are not instances of the class Domega
        TypeError: If the matrix is not 2x2
        ValueError: If the matrix is not unitary
    """
    if not np.all([isinstance(element, Domega) for element in U.flatten()]):
        raise TypeError("Matrix elements must be of class Domega")
    elif U.shape != (2, 2):
        raise TypeError("Matrix must be of size 2x2")
    elif not is_unitary(U):
        raise ValueError("Matrix must be unitary")

    # Load the s3_table into a dictionary
    with open(os.path.join(os.path.dirname(__file__), "s3_table.json"), "r") as f:
        s3_dict = json.load(f)
        s3_dict = {
            k: tuple(tuple(tuple(inner) for inner in outer) for outer in v)
            for k, v in s3_dict.items()
        }
    # Look for first column of powers of omega times U in s3_table
    for i in range(8):
        U_t = np.multiply(OMEGA**i, U)
        for key, value in s3_dict.items():
            # If found, build the last column by multiplying by T^k'
            if convert_to_tuple(U_t) == value:
                # Compute phase differences to find k'
                U_w = apply_sequence(key + "W" * (8 - i))
                k = evaluate_omega_exponent(U[1, 1], U[0, 0].complex_conjugate())
                k_pp = evaluate_omega_exponent(U_w[1, 1], U_w[0, 0].complex_conjugate())
                k_prime = (k - k_pp) % 8
                key += "T" * k_prime
                key += "W" * ((8 - i) % 8)
                return key


def is_unitary(matrix: np.array) -> bool:
    """Check if a matrix with \u2145[\u03C9] elements is unitary

    Args:
        matrix (np.array): Matrix to check

    Returns:
        bool: True if matrix is unitary, False otherwise
    """
    conj_transpose = np.array(
        [[element.complex_conjugate() for element in row] for row in matrix.T]
    )
    product = np.dot(matrix, conj_transpose)
    return product.all() == I.all()


def apply_sequence(sequence: str, U: np.array = I) -> np.array:
    """Apply a sequence of H and T gates to a matrix

    Args:
        sequence (str): Sequence W, H and T gates
        U (np.array): Matrix to apply the sequence to (default is identity matrix)

    Returns:
        np.array: Matrix after applying the sequence of gates

    Raises:
        ValueError: If character in sequence is not H or T

    """
    for char in sequence[::-1]:
        if char == "H":
            U = H @ U
        elif char == "T":
            U = T @ U
        elif char == "W":
            U = np.multiply(OMEGA, U)
        elif char == "":
            continue
        else:
            raise ValueError("Invalid character in sequence")
    return U


def random_sequence(n: int) -> str:
    """Generate a random sequence of H and T gates of length n
    Args:
        n (int): number of H gates in the sequence
    Returns:
        str: Random sequence of H and T gates
    """
    sequence = ""
    for _ in range(n):
        sequence += np.random.choice(["H", "HT", "HTT", "HTTT"])
    return sequence


def convert_to_tuple(array: np.array) -> tuple:
    """Convert a 2x2 array of \u2145[\u03C9] elements to a tuple of tuples of (num, denom)

    Args:
        array (np.array): 2x2 array of \u2145[\u03C9] elements

    Returns:
        tuple: First column in tuple of tuples of (num, denom) where num and denom are entries in \u2145

    Raises:
        TypeError: If matrix elements are not of class \u2145[\u03C9] or matrix is not 2x2
    """
    if not np.all([isinstance(element, Domega) for element in array.flatten()]):
        raise TypeError("Matrix elements must be of class Domega")
    elif array.shape != (2, 2):
        raise TypeError("Matrix must be of size 2x2")
    return tuple(
        tuple((Domega[i].num, Domega[i].denom) for i in range(4)) for Domega in array[:, 0]
    )


def evaluate_omega_exponent(z_1: Domega, z_2: Domega) -> int:
    """Evaluate how many powers of \u03C9 are needed to transform z_2 into z_1
    Args:
        z_1 (Domega): First \u2145[\u03C9] element
        z_2 (Domega): Second \u2145[\u03C9] element
    Returns:
        int: Number of powers of \u03C9 needed to transform z_2 into z_1
    """
    z_1_angle = np.angle(z_1.real() + 1j * z_1.imag())
    z_2_angle = np.angle(z_2.real() + 1j * z_2.imag())
    angle = z_1_angle - z_2_angle
    omega_exponent = int(np.round(angle / (np.pi / 4))) % 8
    return omega_exponent
