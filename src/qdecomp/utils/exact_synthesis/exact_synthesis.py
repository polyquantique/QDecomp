# Copyright 2024-2025 Olivier Romain, Francis Blais, Vincent Girouard, Marius Trudeau
#
#    Licensed under the Apache License, Version 2.0 (the "License");
#    you may not use this file except in compliance with the License.
#    You may obtain a copy of the License at
#
#        http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS,
#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#    See the License for the specific language governing permissions and
#    limitations under the License.

"""
This module performs the exact synthesis of any 2x2 unitary matrix with entries in :math:`\\mathbb{D}[\\omega]` into a
sequence of H and T gates, up to a global phase. It also contains multiple functions to characterize and
generate sequences of H and T gates using the Domega class.

The algorithm is based on the paper ["Fast and efficient exact synthesis of single qubit unitaries
generated by Clifford and T gates](https://arxiv.org/abs/1206.5236) by Vadym Kliuchnikov, Dmitri Maslov,
and Michele Mosca.
"""

import os
import json

import numpy as np

from qdecomp.rings import Domega

H_11 = Domega((-1, 1), (0, 0), (1, 1), (0, 0))  # 1st element of H gate (1/sqrt(2))
ONE_DOMEGA = Domega((0, 0), (0, 0), (0, 0), (1, 0))  # 1st element of T gate (1)
ZERO_DOMEGA = Domega((0, 0), (0, 0), (0, 0), (0, 0))  # 2nd element of T gate (0)
OMEGA = Domega((0, 0), (0, 0), (1, 0), (0, 0))  # OMEGA = e^(i*pi/4)
T_22_INV = Domega((-1, 0), (0, 0), (0, 0), (0, 0))  # 4th element of T^-1 gate (omega^7)
H = np.array([[H_11, H_11], [H_11, -H_11]], dtype=Domega)  # H gate
T = np.array([[ONE_DOMEGA, ZERO_DOMEGA], [ZERO_DOMEGA, OMEGA]], dtype=Domega)  # T gate
T_INV = np.array(
    [[ONE_DOMEGA, ZERO_DOMEGA], [ZERO_DOMEGA, T_22_INV]], dtype=Domega
)  # Inverse of T gate
I = np.array([[ONE_DOMEGA, ZERO_DOMEGA], [ZERO_DOMEGA, ONE_DOMEGA]], dtype=Domega)  # Identity
W = np.multiply(OMEGA, I)  # Gloabal phase gate


def exact_synthesis_alg(U: np.array, insert_global_phase: bool = False) -> str:
    """
    Decompose an unitary 2x2 matrix with elements in :math:`\\mathbb{D}[\\omega]` into a sequence of W, H and T
    gates.

    The algorithm is based on the paper "Fast and efficient exact synthesis of single qubit unitaries
    generated by Clifford and T gates" by Vadym Kliuchnikov, Dmitri Maslov,
    and Michele Mosca [1]_.

    .. [1] Vadym Kliuchnikov, Dmitri Maslov and Michele Mosca, Fast and efficient exact synthesis of single qubit unitaries
    generated by Clifford and T gates, 2013, https://arxiv.org/abs/1206.5236.

    Args:
        U (np.array): Unitary 2x2 matrix to decompose, with elements in Domega
        insert_global_phase (bool): If True, insert the global phase gates in the final sequence Default is `False`

    Returns:
        str: Sequence of W, H and T gates to decompose the matrix

    Raises:
        TypeError: If matrix elements are not elements of the class Domega
        TypeError: If the matrix is not 2x2
        ValueError: If the matrix is not unitary

    # Example:
        >>> # Define the X gate as input
        >>> X = np.array([[ZERO_DOMEGA, ONE_DOMEGA], [ONE_DOMEGA, ZERO_DOMEGA]], dtype=Domega)

        >>> # Perform exact synthesis
        >>> sequence = exact_synthesis_alg(X)
        >>> print(sequence)
        HTTTTH
    """
    if not np.all([isinstance(element, Domega) for element in U.flatten()]):
        raise TypeError(f"The matrix elements must be of class Domega. Got {type(U[0][0])}.")

    elif U.shape != (2, 2):
        raise TypeError(f"The matrix must be of shape 2x2. Got shape {U.shape}.")

    elif not is_unitary_deomega(U):
        raise ValueError("The matrix must be unitary. Got U=\n", U)

    u3_sequence, u3 = exact_synthesis_reduc(U)
    s3_sequence = s3_decomposition(u3, insert_global_phase=insert_global_phase)
    final_sequence = u3_sequence + s3_sequence

    return final_sequence


def exact_synthesis_reduc(U: np.array) -> tuple[str, np.array]:
    """
    Compute the exact synthesis reduction of an unitary 2x2 matrix with elements in :math:`\\mathbb{D}[\\omega]` into the
    sequence that reduces the unitary and a matrix with a sde :math:`\leq 3`.
    The algorithm is based on the paper "Fast and efficient exact synthesis of single qubit unitaries
    generated by Clifford and T gates" by Vadym Kliuchnikov, Dmitri Maslov,
    and Michele Mosca [1]_.

    Args:
        U (np.array): Unitary 2x2 matrix with elements in Domega that needs to be reduced

    Returns:
        str: Sequence of H and T gates to synthesize the matrix
        np.array: Remaining matrix after reduction with a sde <3

    Raises:
        TypeError: If the matrix elements are not instances of the class Domega
        TypeError: If the matrix is not 2x2
        ValueError: If the matrix is not unitary
    """

    if not np.all([isinstance(element, Domega) for element in U.flatten()]):
        raise TypeError(f"The matrix elements must be of class Domega. Got {type(U[0][0])}.")

    elif U.shape != (2, 2):
        raise TypeError(f"The matrix must be of shape 2x2. Got shape {U.shape}.")

    elif not is_unitary_deomega(U):
        raise ValueError("The matrix must be unitary. Got U=\n", U)

    sequence: str = ""
    norm_z = U[0, 0] * U[0, 0].complex_conjugate()
    s = norm_z.sde()

    # Reduce sde until sde <= 3
    while s > 3:

        # Look for the k that reduces the sde by 1
        for k in [0, 1, 2, 3]:
            U_prime = H @ np.linalg.matrix_power(T_INV, k) @ U
            norm_z_prime = U_prime[0, 0] * U_prime[0, 0].complex_conjugate()

            # Add found k to sequence and update U and s
            if norm_z_prime.sde() == s - 1:
                sequence += k * "T" + "H"
                s = norm_z_prime.sde()
                U = U_prime
                break

    return sequence, U


def s3_decomposition(U: np.array, insert_global_phase: bool = False) -> str:
    """
    Find the sequence of W, H and T gates to synthesize a matrix with elements in :math:`\\mathbb{D}[\\omega]` by
    looking in the S3 table.

    Args:
        U (np.array): Matrix to synthesize
        print_global_phase (bool): If True, prints the global phase gates in the final sequence. Default is `False`

    Returns:
        str: Sequence of W, H and T gates to synthesize the matrix

    Raises:
        TypeError: If the matrix elements are not instances of the class Domega
        TypeError: If the matrix is not 2x2
        ValueError: If the matrix is not unitary
        ValueError: If the matrix has sde > 3
    """
    if not np.all([isinstance(element, Domega) for element in U.flatten()]):
        raise TypeError("The matrix elements must be of class Domega")

    elif U.shape != (2, 2):
        raise TypeError("The matrix must be of shape 2x2")

    elif not is_unitary_deomega(U):
        raise ValueError("The matrix must be unitary")

    elif (U[0, 0] * U[0, 0].complex_conjugate()).sde() > 3:
        raise ValueError(
            "The matrix must have a sde < 4, got sde = ",
            (U[0, 0] * U[0, 0].complex_conjugate()).sde(),
        )

    # Load the s3_table into a dictionary
    with open(os.path.join(os.path.dirname(__file__), "s3_table.json"), "r") as f:
        s3_dict = json.load(f)
        s3_dict = {
            k: tuple(tuple(tuple(inner) for inner in outer) for outer in v)
            for k, v in s3_dict.items()
        }

    # Look for first column of powers of omega times U in s3_table
    for i in range(8):
        U_t = np.multiply(OMEGA**i, U)
        for key, value in s3_dict.items():
            # If found, build the last column by multiplying by T^k'
            if Domega_matrix_to_tuple(U_t) == value:

                # Compute phase differences to find k'
                U_w = apply_sequence(key + "W" * (8 - i))

                # If first element is zero, take second element instead
                if U_w[0, 0] == ZERO_DOMEGA:
                    k = get_omega_exponent(U[0, 1], U[1, 0].complex_conjugate())
                    k_pp = get_omega_exponent(U_w[0, 1], U_w[1, 0].complex_conjugate())

                # Else, take first element
                else:
                    k = get_omega_exponent(U[1, 1], U[0, 0].complex_conjugate())
                    k_pp = get_omega_exponent(U_w[1, 1], U_w[0, 0].complex_conjugate())

                # Compute k': real T exponent
                k_prime = (k - k_pp) % 8
                key += "T" * k_prime
                if insert_global_phase:
                    key += "W" * ((8 - i) % 8)

                return key


def is_unitary_deomega(matrix: np.array) -> bool:
    """Check if a matrix with :math:`\\mathbb{D}[\\omega]` elements is unitary

    Args:
        matrix (np.array): Matrix to check

    Returns:
        bool: True if matrix is unitary, False otherwise
    """
    conj_transpose = np.array(
        [[element.complex_conjugate() for element in row] for row in matrix.T]
    )
    product = np.dot(matrix, conj_transpose)
    return (product == I).all()


def apply_sequence(sequence: str, U: np.array = I) -> np.array:
    """Apply a sequence of W, H and T gates to a matrix. If matrix is not provided, the identity matrix is used. Only W, H and T gates are supported.

    Args:
        sequence (str): Sequence W, H and T gates
        U (np.array): Matrix to apply the sequence to (default is identity matrix)

    Returns:
        np.array: Matrix after applying the sequence of gates

    Raises:
        ValueError: If a character in the sequence is not W, H or T

    """
    for char in sequence[::-1]:
        if char == "H":
            U = H @ U

        elif char == "T":
            U = T @ U

        elif char == "W":
            U = np.multiply(OMEGA, U)

        else:
            raise ValueError("Invalid character in sequence")

    return U


def Domega_matrix_to_tuple(array: np.array) -> tuple:
    """Convert the first column of a 2x2 array of :math:`\\mathbb{D}[\\omega]` elements to a tuple of tuples of (num, denom)

    Args:
        array (np.array): 2x2 array of :math:`\\mathbb{D}[\\omega]` elements

    Returns:
        tuple: First column in tuple of tuples of (num, denom) where num and denom are entries in :math:`\\mathbb{D}`

    Raises:
        TypeError: If matrix elements are not of class :math:`\\mathbb{D}[\\omega]` or matrix is not 2x2
    """
    if not np.all([isinstance(element, Domega) for element in array.flatten()]):
        raise TypeError("Matrix elements must be of class Domega")

    elif array.shape != (2, 2):
        raise TypeError("Matrix must be of shape 2x2")

    return tuple(
        tuple((Domega[i].num, Domega[i].denom) for i in range(4)) for Domega in array[:, 0]
    )


def get_omega_exponent(z_1: Domega, z_2: Domega) -> int:
    """Evaluate how many powers of :math:`\\omega` are needed to transform z_2 into z_1
    Args:
        z_1 (Domega): First :math:`\\mathbb{D}[\\omega]` element
        z_2 (Domega): Second :math:`\\mathbb{D}[\\omega]` element
    Returns:
        int: Number of powers of :math:`\\omega` needed to transform z_2 into z_1
    """
    z_1_angle = np.angle(z_1.real() + 1j * z_1.imag())
    z_2_angle = np.angle(z_2.real() + 1j * z_2.imag())

    angle = z_1_angle - z_2_angle
    omega_exponent = int(np.round(angle / (np.pi / 4))) % 8

    return omega_exponent
