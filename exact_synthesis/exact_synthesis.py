import numpy as np

import sys
import os

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))
from Domega import Domega, H, T, T_inv, I


def exact_synthesis(U: np.array) -> str:
    """Exact synthesis of a unitary 2x2 matrix with D[ﾏ云 elements into a sequence
    of H and T gates.

    Implementation of Algorithm 1 from paper Vadym Kliuchnikov,
    Dmitri Maslov, and Michele Mosca. Fast and efficient exact synthesis of single
    qubit unitaries generated by Clifford and T gates. Feb. 27, 2013.
    doi: 10.48550/arXiv.1206.5236

    Args:
        U (np.array): Unitary 2x2 array to synthesize with elements in Domega

    Returns:
        str: Sequence of H and T gates to synthesize the matrix

    Raises:
        TypeError: If matrix elements are not of class D[ﾏ云 or matrix is not 2x2
        ValueError: If matrix is not unitary
    """

    if not np.all([isinstance(element, Domega) for element in U.flatten()]):
        raise TypeError("Matrix elements must be of class D[ﾏ云")
    elif U.shape != (2, 2):
        raise TypeError("Matrix must be of size 2x2")
    elif not is_unitary(U):
        raise ValueError("Matrix must be unitary")

    sequence: str = ""
    norm_z = U[0, 0] * U[0, 0].complex_conjugate()
    s = norm_z.sde()
    print(s)
    while s > 3:
        for k in [0, 1, 2, 3]:
            U_prime = H @ np.linalg.matrix_power(T_inv, k) @ U
            norm_z_prime = U_prime[0, 0] * U_prime[0, 0].complex_conjugate()
            if norm_z_prime.sde() == s - 1:
                sequence += k * "T" + "H"
                s = norm_z_prime.sde()
                U = U_prime
                break
    return sequence, U


def is_unitary(matrix):
    """Check if a matrix with D[ﾏ云 elements is unitary

    Args:
        matrix (np.array): Matrix to check

    Returns:
        bool: True if matrix is unitary, False otherwise
    """
    conj_transpose = conj_transpose = np.array(
        [[element.complex_conjugate() for element in row] for row in matrix.T]
    )
    product = np.dot(matrix, conj_transpose)
    return product.all() == I.all()


def apply_sequence(sequence: str, U: np.array = I) -> np.array:
    """Apply a sequence of H and T gates to a matrix

    Args:
        sequence (str): Sequence H and T gates
        U (np.array): Matrix to apply the sequence to (default is identity matrix)

    Returns:
        np.array: Matrix after applying the sequence of gates

    Raises:
        ValueError: If character in sequence is not H or T

    """
    for char in sequence[::-1]:
        if char == "H":
            U = H @ U
        elif char == "T":
            U = T @ U
        else:
            raise ValueError("Invalid character in sequence")
    return U


def random_sequence(n: int) -> str:
    """Generate a random sequence of H and T gates of length n
    Args:
        n (int): Length of the sequence
    Returns:
        str: Random sequence of H and T gates
    """
    sequence = ""
    for _ in range(n):  # Assure H doesnt repeat twice and T doesnt repeat 4 times
        sequence += np.random.choice(["H", "HT", "HTT", "HTTT"])
    return sequence


if __name__ == "__main__":
    U = apply_sequence(random_sequence(10))
    print(f"Initial gate : \n{U}")
    sequence, U_f = exact_synthesis(U)
    print(f"Sequence : {sequence}")
    print(f"Matrix with s<3 : \n{U_f}")
    print(f"Final matrix : \n{apply_sequence(sequence, U_f)}")
    assert U.all() == apply_sequence(sequence, U_f).all()
